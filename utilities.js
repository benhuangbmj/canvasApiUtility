const express = require('express');
const app = express();
const axios = require('axios');
const path = require('path');
const fetch = require('@replit/node-fetch');
//const fetch = require('node-fetch');
const cron = require('node-cron');
require('dotenv').config();

//This block tests utilities
{
  const sendMessage = false;
  const schedule = " 30 14 16 * * *"
  const userId ="190000005530740";
  const canvasUrl = 'https://canvas.test.instructure.com';
  const myToken = process.env['CANVAS_API_TOKEN_TEST'];
  const headers = {
    Authorization: `Bearer ${myToken}`,
    Accept: "application/json+canvas-string-ids"
  }
  const headersBackup = headers; //delete
  let url = path.join(canvasUrl, 'api/v1/conversations');

  const courses = ["190000001927022", "190000001927048", "190000001927031"];

  const body = {
    recipients: [userId],
    subject: 'test',
    body: "This is a multiline message generated by quotes.\nthis is the second line. This is the third.",
    force_new: true
  }

      
  function fetchPost(url, headers, body) 
  {
    const headersPost = Object.assign({'Content-type': 'application/json'}, headers);
    fetch(url, {
      method: 'POST',
      body: JSON.stringify(body),
      headers: headersPost
    }).then(res => {
      if (!res.ok) {
      console.log(body);
      console.log(res.statusText);
      }
      console.log('X-Rate-Limit-Remaining:', res.headers.get('X-Rate-Limit-Remaining'));
    });
  }
  
  module.exports.fetchPost = fetchPost;

  module.exports.getSubmissions = async function(urlPrefix=canvasUrl, headers=headersBackup, courseId = '190000001927031', assignmentId = '190000016498887') {
    const url = path.join(urlPrefix, `api/v1/courses/${courseId}/assignments/${assignmentId}/submissions?include[]=user`);
    const submissions = await fetch(url,{
      headers: headers
    });
    return submissions;
  }

  const createAssignment = function(urlPrefix = canvasUrl, headers = headersBackup, courseId = '190000001927022') {
    const url = path.join(urlPrefix, `/api/v1/courses/${courseId}/assignments`);
    const body = {
      assignment: {
        name: 'Lab 1',
        submission_type: "none",
        published: true,
        description: `
        <div>
          <a href='https://www.google.com'>The link</a>
        </div>        `
      }
    }
    fetchPost(url, headers, body);
  }
  module.exports.createAssignment = createAssignment;
  
  const createConversation = function(urlPrefix, headers, recipientId, subject, message) {
    const url = path.join(canvasUrl, 'api/v1/conversations');
    const body = {
      recipients: [recipientId],
      subject: subject,
      body: message//,
      //force_new: true
    }
    fetchPost(url, headers, body);    
  }
/*  
  const getProfile = async function () {
    let data = await fetch(canvasUrl + '/api/v1/users/190000005920013/profile', {
      headers: headers
    });
    data = await data.json();
      console.log(data);
    return data;
  };
*/
//190000001883402 190000001927022
  const checkOverdue = async (sendMessage, courseId=courses[0], urlPrefix=canvasUrl, headers=headersBackup) => {//take away the "sendMessage" switch
    
    const now = new Date();
    const users = new Map();      
    const url = path.join(urlPrefix, `/api/v1/courses/${courseId}/assignments?include[]=all_dates`);
    let currAssignments;
    let pageAssig = 1;
    let result = [];
    while(currAssignments = await fetchPage(url, headers, pageAssig)) {
      pageAssig++;
      currAssignments = currAssignments.filter(entry => {
        const dates = entry.all_dates.filter(entry => entry.base)[0];
        const dueAt = new Date(dates.due_at);
        return dayDiff(now, dueAt) > 0  && dayDiff(now, dueAt) < 9 && !entry.omit_from_final_grade;//fix
      });
      for(let assignmentCount = 0; assignmentCount < currAssignments.length; assignmentCount++) {
        const assignment = currAssignments[assignmentCount];
        const pointsPossible = assignment.points_possible;
        const restDays = 9 - dayDiff(now, new Date(assignment.all_dates[0].due_at));
        const url = path.join(urlPrefix, `/api/v1/courses/${courseId}/assignments/${assignment.id}/submissions?include[]=user`);
        let currSubmissions;
        let pageSub = 1;
        while(currSubmissions = await fetchPage(url, headers, pageSub)) {
          pageSub++;
          //gathering the non-full-scored submissions
          currSubmissions = currSubmissions.filter(submission => {
            return submission.user.name != 'Test Student' && submission.workflow_state != 'submitted' && submission.grade_matches_current_submission && !(submission.score >= pointsPossible);
          })
          const messageTemplate = function(assignmentName, restDays, userStatus) {
            return `\n${assignmentName}, ${userStatus}, ${restDays} days left before the closing.`
          }
          currSubmissions.forEach(submission => {
            const userName = submission.user.name.split(' ').slice(0,1).join('');
            const assignmentName = assignment.name;
            const userId = submission.user_id;
            const userStatus = submission.score || submission.score == 0? parseFloat(submission.score.toFixed(2)) + "/" + pointsPossible : 'unsubmitted';
            if(!users.has(userId)) {
              let message = `*This message is auto-generated.* \n${userName}, \nYou have either not submitted or not acquired the full score of each of the following assignments yet.` + messageTemplate(assignmentName, restDays,userStatus);
              users.set(userId, message);
            } else {
              let message = users.get(userId);
              message = message + messageTemplate(assignmentName, restDays,userStatus);
              users.set(userId, message);
            }
          });
        };        
      };        
    };
    //Attempt to get around the Canvas rate limit 
    if(sendMessage) {
      const userArr = [];
      for (let [user,message] of users) {
        userArr.push([user,message]);
      }
      let userCount = 0;
      const sendRequest = setInterval(function() {
        if (userCount == userArr.length) {
          clearInterval(sendRequest);
          return;
        }
        createConversation(urlPrefix, headers, userArr[userCount][0], 'Overdue or Underscored', userArr[userCount][1]);
        userCount++;
      }, 200);
    }//send message
    //return result;//delete
    for (let [user, message] of users) {
      console.log(message);
    }//delete
  };
  module.exports.checkOverdue = checkOverdue;
  
  module.exports.checkOverdueCron = function() {
    const job = cron.schedule(schedule, function() {//remove the "schedule" & use the selected time of the user
      for(let i = 0; i < courses.length; i++)
      checkOverdue(sendMessage, courses[i]);   
    }, {
      timezone: "America/New_York" //use the timezone of the individual user
    })
  }
}//End of the testing block

//Helper functions


//Canvas API Utilities:

const dayDiff = function(date1, date2) {
  return Math.floor((date1-date2)/1000/3600/24);
}
const fetchPage = async function(url, headers, page, method = 'get', body = null) {
  url = new URL(url);
  url.searchParams.append('page', page);
  options = {
    method: method,
    headers: headers
  }
  if (body) options.body = body;
  let response = await fetch(url, options);
  if(!response.ok) {
    console.log(response.statusText);
    return;
  }
  response = await response.json();
  return response.length > 0? response : false;
}

module.exports.getProfile = async function({urlPrefix, headers, token, envir}) {
  const url = path.join(urlPrefix, '/api/v1/users/self/profile');
  let profile = await fetch(url, {
    headers: headers
  });
  if(!profile.ok) {
    let err = await Error(profile.statusText);
    err = await err.toString();
    return err;
  }
  profile = await profile.json();
  const id = profile.id;
  const findUser = require('./database').findUser;
  const user = await findUser(id, envir, token);
  if(!user) {
    const createUser = require('./database').createUser;
    const user = await createUser(id, profile.name, profile.primary_email,token,envir);
    user.envir = envir;
    return user;
  }
  //The additional information needed to construct the profile page.
  const addon = {
    returning: true,
    envir: envir
  };
  Object.assign(user,addon);
  return user;
}


module.exports.getCourses = function(urlPrefix, headers) {
  return fetch(urlPrefix + '/api/v1/courses?enrollment_state=active&enrollment_type=teacher&per_page=50', {
  headers: headers,
  }).then(res=>{
    if (!res.ok) {
      throw Error(res.statusText);
    }
    return res.json();
  }).then(res => {
    let courses = res.map(entry => {
      return {
        id: entry.id, 
        name: entry.name, 
        course_code: entry.course_code
      }
    });
    return courses;
  });
};//address the pagination later


//Database Utilities:
module.exports.subscribe = async function(obj) {
  const profile = await require('./database.js').findProfile(obj.session.userId);
  const newSub = obj.body;
  const currSub = profile.services;
  const services = Object.keys(currSub);
  
  for (let service of services) {
    const subscription = {
      active: false,
      courses: []
    };
    
    if (newSub[service + '-sub'] && newSub[service]) {
      subscription.active = true;
      if(!Array.isArray(newSub[service])) newSub[service] = [newSub[service]];
      subscription.courses = newSub[service];
    }
    Object.assign(currSub[service], subscription);
  }
   return profile.save().catch(err => console.log(err));  
}
